+++
title = "Cargo Notes"
description = "Notes from building a test crate under various circumstances using Rust's Cargo package manager."
date = 2019-10-30
+++

# Cargo Notes

<div class="tc-tiddler-body tc-reveal"><ul><li>If the file exists, <code>cargo</code> will use <code>Cargo.lock</code> to decide which dependencies to download and build.</li><li><code>cargo update</code> is effectively equivalent to removing <code>Cargo.lock</code> and then running <code>cargo build</code> <em>if</em> there wasn't a <code>cargo clean</code> in-between. It updates <code>Cargo.lock</code> with more recent compatible versions of packages in the repo.</li><li>Cargo uses feature unions if two crates have a dependency on the same version of another crate (<em>including version</em>) and they enable different features (<a class="tc-tiddlylink-external" href="https://github.com/rust-lang/cargo/issues/4463#issuecomment-327272773" rel="noopener noreferrer" target="_blank">Source1</a>) (<a class="tc-tiddlylink-external" href="https://github.com/rust-lang/cargo/issues/6121#issuecomment-426898639" rel="noopener noreferrer" target="_blank">Source2</a>).<ul><li>By convention, according to Discourse forums and cargo devs, <code>cargo</code> features are supposed to be <a class="tc-tiddlylink-external" href="https://github.com/rust-lang/cargo/issues/4328" rel="noopener noreferrer" target="_blank">additive</a>. This has been known to <a class="tc-tiddlylink-external" href="https://github.com/rust-lang/cargo/issues/5730" rel="noopener noreferrer" target="_blank">break</a> <code>no_std</code> applications.</li><li>This feature-union convention could be subject to change in the semi-near future? I wonder if the old behavior could also possibly be kept to facilitate dependency reuse/not having multiple versions of the same crate in a library/application...</li></ul></li><li>The same crate with two different versions are <em>not</em> considered the same crate, and trying to use types from one crate in another will error out.</li><li>Caret versioning is default in <code>Cargo.toml</code>. See <a class="tc-tiddlylink-external" href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#caret-requirements" rel="noopener noreferrer" target="_blank">here</a> for more information about what a compatible version means. I.e. if not using <code>Cargo.lock</code>, <code>cargo</code> will check if a newer version exists (both on disk and from the repo) before deciding what version of a crate to (possibly download and) build.<ul><li>With caret versioning, it is possible that two crates specifying two different versions of a crate dependency end up <em>both</em> using- <em>and sharing!</em>- a newer third version instead.</li><li>Since <code>cargo</code> works on a DAG, crates whose deps were updated as a result of <code>cargo update</code> (which can happen if their <code>Cargo.toml</code>s use caret versioning) will be rebuilt as well.</li></ul></li><li>If you have a wildcard dependency and a clean build, <code>cargo</code> will use the most up-to-date version from the repository.<ul><li><s>If you change a concrete version of a dependency to a wildcard, and do not clean your dependencies (and delete <code>Cargo.lock</code>), <code>cargo</code> will use the existing crate version on-disk already to satisfy the wildcard, even if its a less recent version.</s> I can't seem to duplicate this. Looks like I forgot to delete <code>Cargo.lock</code> when I observed this behavior? See <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#CargoDump">CargoDump</a>.</li></ul></li><li><code>cargo</code> doesn't download/build crates if it doesn't have to. This can be demonstrated by taking a repo with dependencies still intact, making a copy of <code>Cargo.lock</code>, running <code>cargo update</code>, <code>cargo build</code>, and then replacing the updated <code>Cargo.lock</code> with the old one.<ul><li>Because a binary built with the old <code>Cargo.lock</code> already exists, <code>cargo</code> will simply hard link the binary under <code>target</code> to the existing old binary to &quot;build&quot; it.</li></ul></li></ul></div>
